From: David S. Miller <davem@davemloft.net>
Date: Fri, 28 Dec 2007 21:55:06 +0000 (+0200)
Subject: Remove DRI support to fix build after devPrivates rework
X-Git-Url: http://gitweb.freedesktop.org/?p=xorg/driver/xf86-video-sunffb.git;a=commitdiff;h=843d93e775cd46a0e24e1a725594fa2d942f14ba

Remove DRI support to fix build after devPrivates rework

This driver uses devprivates of all kinds, but this is
only done in deprecated and unused code so we can simply
remove it all.

DRM/DRI support has been commented out for years, and was
done during the conversion over to XAA acceleration.  This
code would need to be essentially rewritten to work again,
so we can just remove this stuff for now.

The rest were either:

1) DRI/DRM related uses
2) the private allocation code
3) cases that could index to the pScrn to get the FFB private

And that's all fixed up here.

Signed-off-by: David S. Miller <davem@davemloft.net>
---

--- a/src/ffb.h
+++ b/src/ffb.h
@@ -39,10 +39,6 @@
 #include "ffb_regs.h"
 #include "xf86sbusBus.h"
 #include "ffb_dac.h"
-#ifdef XF86DRI
-#include "xf86drm.h"
-#include "ffb_drishare.h"
-#endif
 #ifndef  DPMS_SERVER
 #define  DPMS_SERVER
 #endif   /* DPMS_SERVER */
@@ -97,14 +93,6 @@ typedef struct {
 	unsigned int bits[32];			/* The stipple bits themselves	*/
 } CreatorStippleRec, *CreatorStipplePtr;
 
-typedef struct {
-	int type;
-	unsigned int linepat;
-	CreatorStipplePtr stipple;
-	void (*PolySegment)(DrawablePtr, GCPtr, int, xSegment *);
-	void (*Polylines)(DrawablePtr, GCPtr, int, int, DDXPointPtr);
-} CreatorPrivGCRec, *CreatorPrivGCPtr;
-
 /* WID and framebuffer controls are a property of the
  * window.
  */
@@ -135,12 +123,6 @@ enum ffb_chip_type {
 	afb_m6			/* FCS Elite3D, 6 float chips */
 };
 
-#ifdef XF86DRI
-typedef struct {
-	int	index;
-} FFBConfigPrivRec, *FFBConfigPrivPtr;
-#endif
-
 typedef struct {
 	unsigned short fifo_cache;
 	unsigned short rp_active;
@@ -221,16 +203,6 @@ typedef struct {
 	void *I2C;
 	struct ffb_dac_info dac_info;
 
-#ifdef XF86DRI
-	void *pDRIInfo;
-	int numVisualConfigs;
-	void *pVisualConfigs;
-	FFBConfigPrivPtr pVisualConfigsPriv;
-	int drmSubFD;
-	Bool dri_enabled;
-	ffb_dri_state_t *pFfbSarea;
-#endif
-
 	OptionInfoPtr Options;
 } FFBRec, *FFBPtr;
 
@@ -261,18 +233,10 @@ extern void FFBWidFree(FFBPtr, unsigned 
 extern unsigned int FFBWidUnshare(FFBPtr, unsigned int);
 extern unsigned int FFBWidReshare(FFBPtr, unsigned int);
 extern void FFBWidChangeBuffer(FFBPtr, unsigned int, int);
-extern Bool FFBWidIsShared(FFBPtr pFfb, unsigned int wid);
 
 /* Accelerated double-buffering. */
 extern Bool FFBDbePreInit(ScreenPtr);
 
-#ifdef XF86DRI
-/* DRI support */
-extern Bool FFBDRIScreenInit(ScreenPtr);
-extern Bool FFBDRIFinishScreenInit(ScreenPtr);
-extern void FFBDRICloseScreen(ScreenPtr);
-#endif
-
 /* The fastfill and pagefill buffer sizes change based upon
  * the resolution.
  */
@@ -290,24 +254,8 @@ extern struct fastfill_parms ffb_fastfil
 
 #define FFB_FFPARMS(__fpriv)	(ffb_fastfill_parms[(__fpriv)->ffb_res])
 
-extern int  CreatorScreenPrivateIndex;
-extern int  CreatorGCPrivateIndex;
-extern int  CreatorWindowPrivateIndex;
-
 #define GET_FFB_FROM_SCRN(p)	((FFBPtr)((p)->driverPrivate))
 
-#define GET_FFB_FROM_SCREEN(s)						\
-((FFBPtr)(s)->devPrivates[CreatorScreenPrivateIndex].ptr)
-
-#define CreatorGetGCPrivate(g)						\
-((CreatorPrivGCPtr) (g)->devPrivates [CreatorGCPrivateIndex].ptr)
-
-#define CreatorGetWindowPrivate(w)					\
-((CreatorPrivWinPtr) (w)->devPrivates[CreatorWindowPrivateIndex].ptr)
-                            
-#define CreatorSetWindowPrivate(w,p) 					\
-((w)->devPrivates[CreatorWindowPrivateIndex].ptr = (pointer) p)
-
 #undef DEBUG_FFB
 
 #ifdef DEBUG_FFB
--- a/src/ffb_accel.c
+++ b/src/ffb_accel.c
@@ -44,11 +44,6 @@
 #include	"ffb_loops.h"
 #include	"ffb_regs.h"
 
-int	CreatorScreenPrivateIndex;
-int	CreatorGCPrivateIndex;
-int	CreatorWindowPrivateIndex;
-int	CreatorGeneration;
-
 /* Indexed by ffb resolution enum. */
 struct fastfill_parms ffb_fastfill_parms[] = {
 	/* fsmall, psmall,  ffh,  ffw,  pfh,  pfw */
@@ -61,7 +56,8 @@ struct fastfill_parms ffb_fastfill_parms
 void
 CreatorVtChange (ScreenPtr pScreen, int enter)
 {
-	FFBPtr pFfb = GET_FFB_FROM_SCREEN (pScreen);
+	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
+	FFBPtr pFfb = GET_FFB_FROM_SCRN (pScrn);
 	ffb_fbcPtr ffb = pFfb->regs;
 
 	pFfb->rp_active = 1;
@@ -847,22 +843,6 @@ Bool FFBAccelInit(ScreenPtr pScreen, FFB
 	XAAInfoRecPtr infoRec;
 	ffb_fbcPtr ffb = pFfb->regs;
 
-	if (serverGeneration != CreatorGeneration) {
-		CreatorScreenPrivateIndex = AllocateScreenPrivateIndex ();
-		if (CreatorScreenPrivateIndex == -1)
-			return FALSE;
-		CreatorGCPrivateIndex = AllocateGCPrivateIndex ();
-		CreatorWindowPrivateIndex = AllocateWindowPrivateIndex ();
-		CreatorGeneration = serverGeneration;
-	}
-	
-	if (!AllocateGCPrivate(pScreen, CreatorGCPrivateIndex, sizeof(CreatorPrivGCRec)))
-		return FALSE;
-	if (!AllocateWindowPrivate(pScreen, CreatorWindowPrivateIndex, 0))
-		return FALSE;
-
-	pScreen->devPrivates[CreatorScreenPrivateIndex].ptr = pFfb;
-
 	pFfb->xaa_fbc = (FFB_FBC_WB_A | FFB_FBC_WM_COMBINED | FFB_FBC_RB_A |
 			 FFB_FBC_WE_FORCEON |
 			 FFB_FBC_SB_BOTH |
--- a/src/ffb_attr.c
+++ b/src/ffb_attr.c
@@ -81,180 +81,3 @@ void __FFB_Attr_SFB_VAR(FFBPtr pFfb, uns
 	ffb->rop = rop;
 	ffb->pmask = pmask;
 }
-
-#define NEED_PPC	0x00000001
-#define NEED_PMASK	0x00000002
-#define NEED_ROP	0x00000004
-#define NEED_DRAWOP	0x00000008
-#define NEED_FG		0x00000010
-#define NEED_BG		0x00000020
-#define NEED_FBC	0x00000040
-#define NEED_WID	0x00000080
-
-void __FFB_Attr_GC(FFBPtr pFfb, GCPtr pGC, WindowPtr pWin, unsigned int ppc, int drawop)
-{
-	ffb_fbcPtr ffb = pFfb->regs;
-	unsigned int rop, need_mask, need_count;
-
-	need_mask = need_count = 0;
-	if ((pFfb->ppc_cache & FFB_PPC_GCMASK) != ppc) {
-		unsigned int newppc = pFfb->ppc_cache & ~FFB_PPC_GCMASK;
-
-		newppc |= (ppc & FFB_PPC_GCMASK);
-		pFfb->ppc_cache = newppc;
-		need_mask |= NEED_PPC;
-		need_count++;
-	}
-
-	if (pFfb->pmask_cache != pGC->planemask) {
-		pFfb->pmask_cache = pGC->planemask;
-		need_mask |= NEED_PMASK;
-		need_count++;
-	}
-
-	rop = (pGC->alu | FFB_ROP_EDIT_BIT)|(FFB_ROP_NEW<<8);
-	if (pFfb->rop_cache != rop) {
-		pFfb->rop_cache = rop;
-		need_mask |= NEED_ROP;
-		need_count++;
-	}
-
-	if (pFfb->drawop_cache != drawop) {
-		pFfb->drawop_cache = drawop;
-		need_mask |= NEED_DRAWOP;
-		need_count++;
-	}
-
-	if (pFfb->fg_cache != pGC->fgPixel) {
-		pFfb->fg_cache = pGC->fgPixel;
-		need_mask |= NEED_FG;
-		need_count++;
-	}
-
-	{
-		CreatorPrivWinPtr WinPriv = CreatorGetWindowPrivate(pWin);
-		unsigned int fbc = WinPriv->fbc_base;
-
-		fbc &= ~FFB_FBC_XE_MASK;
-		fbc |= FFB_FBC_XE_OFF;
-
-		if (pFfb->fbc_cache != fbc) {
-			pFfb->fbc_cache = fbc;
-			need_mask |= NEED_FBC;
-			need_count++;
-		}
-
-	}
-	pFfb->rp_active = 1;
-
-	FFBLOG(("WRATTRS_GC: PPC[%08x:%08x] PMSK[%08x] ROP[%08x] "
-		"DOP[%08x] FG[%08x] FBC[%08x]\n",
-		pFfb->ppc_cache & FFB_PPC_GCMASK, FFB_PPC_GCMASK,
-		pFfb->pmask_cache, pFfb->rop_cache,
-		pFfb->drawop_cache, pFfb->fg_cache, pFfb->fbc_cache));
-
-	FFBFifo(pFfb, need_count);
-	if (need_mask & NEED_PPC)
-		ffb->ppc = (pFfb->ppc_cache & FFB_PPC_GCMASK);
-	if (need_mask & NEED_PMASK)
-		ffb->pmask = pFfb->pmask_cache;
-	if (need_mask & NEED_ROP)
-		ffb->rop = pFfb->rop_cache;
-	if (need_mask & NEED_DRAWOP)
-		ffb->drawop = pFfb->drawop_cache;
-	if (need_mask & NEED_FG)
-		ffb->fg = pFfb->fg_cache;
-	if (need_mask & NEED_FBC)
-		ffb->fbc = pFfb->fbc_cache;
-}
-
-void __FFB_Attr_FastfillWin(FFBPtr pFfb, WindowPtr pWin,
-			    unsigned int ppc, unsigned int pixel)
-{
-	ffb_fbcPtr ffb = pFfb->regs;
-	unsigned int rop, need_mask, need_count;
-
-	need_mask = need_count = 0;
-	if ((pFfb->ppc_cache & FFB_PPC_WINMASK) != ppc) {
-		unsigned int newppc = pFfb->ppc_cache & ~FFB_PPC_WINMASK;
-
-		newppc |= (ppc & FFB_PPC_WINMASK);
-		pFfb->ppc_cache = newppc;
-		need_mask |= NEED_PPC;
-		need_count++;
-	}
-
-	if (pFfb->pmask_cache != 0x00ffffff) {
-		pFfb->pmask_cache = 0x00ffffff;
-		need_mask |= NEED_PMASK;
-		need_count++;
-	}
-
-	rop = FFB_ROP_NEW | (FFB_ROP_NEW<<8);
-	if (pFfb->rop_cache != rop) {
-		pFfb->rop_cache = rop;
-		need_mask |= NEED_ROP;
-		need_count++;
-	}
-
-	if (pFfb->drawop_cache != FFB_DRAWOP_FASTFILL) {
-		pFfb->drawop_cache = FFB_DRAWOP_FASTFILL;
-		need_mask |= NEED_DRAWOP;
-		need_count++;
-	}
-
-	if (pFfb->fg_cache != pixel) {
-		pFfb->fg_cache = pixel;
-		need_mask |= NEED_FG;
-		need_count++;
-	}
-
-	{
-		CreatorPrivWinPtr pWinPriv = CreatorGetWindowPrivate(pWin);
-		unsigned int fbc = pWinPriv->fbc_base;
-
-		if (pFfb->has_double_buffer) {
-			fbc &= ~FFB_FBC_WB_MASK;
-			fbc |= FFB_FBC_WB_AB;
-		}
-		fbc &= ~(FFB_FBC_XE_MASK | FFB_FBC_RGBE_MASK);
-		fbc |= FFB_FBC_XE_ON | FFB_FBC_RGBE_ON;
-		if (pFfb->ffb_res == ffb_res_high)
-			fbc |= FFB_FBC_WB_B;
-
-		if (pFfb->fbc_cache != fbc) {
-			pFfb->fbc_cache = fbc;
-			need_mask |= NEED_FBC;
-			need_count++;
-		}
-
-		if (pFfb->wid_cache != pWinPriv->wid) {
-			pFfb->wid_cache = pWinPriv->wid;
-			need_mask |= NEED_WID;
-			need_count++;
-		}
-	}
-
-	pFfb->rp_active = 1;
-
-	FFBLOG(("WRATTRS_GC: PPC[%08x:%08x] PMSK[%08x] ROP[%08x] DOP[%08x] FG[%08x] FBC[%08x] WID[%02x]\n",
-		pFfb->ppc_cache & FFB_PPC_WINMASK, FFB_PPC_WINMASK,
-		pFfb->pmask_cache, pFfb->rop_cache,
-		pFfb->drawop_cache, pFfb->fg_cache, pFfb->fbc_cache, pFfb->wid_cache));
-
-	FFBFifo(pFfb, need_count);
-	if (need_mask & NEED_PPC)
-		ffb->ppc = (pFfb->ppc_cache & FFB_PPC_WINMASK);
-	if (need_mask & NEED_PMASK)
-		ffb->pmask = pFfb->pmask_cache;
-	if (need_mask & NEED_ROP)
-		ffb->rop = pFfb->rop_cache;
-	if (need_mask & NEED_DRAWOP)
-		ffb->drawop = pFfb->drawop_cache;
-	if (need_mask & NEED_FG)
-		ffb->fg = pFfb->fg_cache;
-	if (need_mask & NEED_FBC)
-		ffb->fbc = pFfb->fbc_cache;
-	if (need_mask & NEED_WID)
-		ffb->wid = pFfb->wid_cache;
-}
--- a/src/ffb_dri.c
+++ /dev/null
@@ -1,521 +0,0 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sunffb/ffb_dri.c,v 1.8 2001/04/18 14:52:42 dawes Exp $
- * Acceleration for the Creator and Creator3D framebuffer - DRI/DRM support.
- *
- * Copyright (C) 2000 David S. Miller (davem@redhat.com)
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * DAVID MILLER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
- * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include <stdio.h>
-
-#include "xf86.h"
-#include "xf86_OSproc.h"
-#include "xf86Priv.h"
-
-#include "xf86PciInfo.h"
-#include "xf86Pci.h"
-
-#include "miline.h"
-
-#include "GL/glxtokens.h"
-
-#include "xf86drm.h"
-#include "sarea.h"
-#define _XF86DRI_SERVER_
-#include "dri.h"
-
-#include "GL/glxint.h"
-
-#include "ffb.h"
-#include "ffb_regs.h"
-#include "ffb_fifo.h"
-#include "ffb_rcache.h"
-
-static char FFBKernelDriverName[] = "ffb";
-static char FFBClientDriverName[] = "ffb";
-
-/* Forward declarations. */
-static Bool FFBDRICreateContext(ScreenPtr, VisualPtr, drm_context_t,
-				void *, DRIContextType);
-static void FFBDRIDestroyContext(ScreenPtr, drm_context_t, DRIContextType);
-
-static void FFBDRIInitBuffers(WindowPtr, RegionPtr, CARD32);
-static void FFBDRIMoveBuffers(WindowPtr, DDXPointRec, RegionPtr, CARD32);
-
-static void FFBDRISetDrawableIndex(WindowPtr, CARD32);
-
-/* XXX Why isn't this in a header somewhere? XXX */
-extern void GlxSetVisualConfigs(int nconfigs, __GLXvisualConfig *configs,
-				void **configprivs);
-
-static Bool
-FFBDRIInitVisualConfigs(ScreenPtr pScreen)
-{
-	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
-	FFBPtr pFfb = GET_FFB_FROM_SCRN(pScrn);
-	__GLXvisualConfig *pConfigs;
-	FFBConfigPrivPtr pFfbConfigs;
-	FFBConfigPrivPtr *pFfbConfigPtrs;
-
-	pConfigs = (__GLXvisualConfig *)
-		xcalloc(sizeof(__GLXvisualConfig), 1);
-	if (!pConfigs)
-		return FALSE;
-
-	pFfbConfigs = (FFBConfigPrivPtr)
-		xcalloc(sizeof(FFBConfigPrivRec), 1);
-	if (!pFfbConfigs) {
-		xfree(pConfigs);
-		return FALSE;
-	}
-
-	pFfbConfigPtrs = (FFBConfigPrivPtr *)
-		xcalloc(sizeof(FFBConfigPrivPtr), 1);
-	if (!pFfbConfigPtrs) {
-		xfree(pConfigs);
-		xfree(pFfbConfigs);
-		return FALSE;
-	}
-
-	pFfbConfigPtrs[0] = &pFfbConfigs[0];
-
-	pConfigs->vid = -1;
-	pConfigs->class = -1;
-	pConfigs->rgba = TRUE;
-	pConfigs->redSize = 8;
-	pConfigs->greenSize = 8;
-	pConfigs->blueSize = 8;
-	pConfigs->alphaSize = 0;
-	pConfigs->redMask = 0x000000ff;
-	pConfigs->greenMask = 0x0000ff00;
-	pConfigs->blueMask = 0x00ff0000;
-	pConfigs->alphaMask = 0;
-	pConfigs->accumRedSize = 0;
-	pConfigs->accumGreenSize = 0;
-	pConfigs->accumBlueSize = 0;
-	pConfigs->accumAlphaSize = 0;
-	pConfigs->doubleBuffer = TRUE;
-	pConfigs->stereo = FALSE;
-	pConfigs->bufferSize = 32;
-	pConfigs->depthSize = 16;
-	pConfigs->stencilSize = 0;
-	pConfigs->auxBuffers = 0;
-	pConfigs->level = 0;
-	pConfigs->visualRating = GLX_NONE;
-	pConfigs->transparentPixel = GLX_NONE;
-	pConfigs->transparentRed = 0;
-	pConfigs->transparentGreen = 0;
-	pConfigs->transparentBlue = 0;
-	pConfigs->transparentAlpha = 0;
-	pConfigs->transparentIndex = 0;
-
-	pFfb->numVisualConfigs = 1;
-	pFfb->pVisualConfigs = pConfigs;
-	pFfb->pVisualConfigsPriv = pFfbConfigs;
-
-	GlxSetVisualConfigs(1, pConfigs, (void **)pFfbConfigPtrs);
-
-	return TRUE;
-}
-
-static void
-init_ffb_sarea(FFBPtr pFfb, ffb_dri_state_t *pFfbSarea)
-{
-	int i;
-
-	pFfbSarea->flags = 0;
-
-	switch (pFfb->ffb_type) {
-	case ffb2_prototype:
-	case ffb2_vertical:
-	case ffb2_vertical_plus:
-	case ffb2_horizontal:
-	case ffb2_horizontal_plus:
-		pFfbSarea->flags |= FFB_DRI_FFB2;
-		break;
-
-	default:
-		break;
-	};
-
-	if (pFfb->ffb_type == ffb2_vertical_plus ||
-	    pFfb->ffb_type == ffb2_horizontal_plus)
-		pFfbSarea->flags |= FFB_DRI_FFB2PLUS;
-
-	if (pFfb->dac_info.flags & FFB_DAC_PAC1)
-		pFfbSarea->flags |= FFB_DRI_PAC1;
-
-	if (pFfb->dac_info.flags & FFB_DAC_PAC2)
-		pFfbSarea->flags |= FFB_DRI_PAC2;
-
-	for (i = 0; i < FFB_DRI_NWIDS; i++)
-		pFfbSarea->wid_table[i] = 0;
-}
-
-#define	FFB_DFB24_POFF		0x02000000UL
-#define	FFB_DFB24_SIZE		0x01000000UL
-
-#define	FFB_FBC_REGS_POFF	0x00600000UL
-#define	FFB_FBC_REGS_SIZE	0x00002000UL
-
-#define	FFB_DAC_POFF		0x00400000UL
-#define	FFB_DAC_SIZE		0x00002000UL
-
-#define	FFB_SFB8R_POFF		0x04000000UL
-#define FFB_SFB8R_SIZE		0x00400000UL
-
-#define	FFB_SFB32_POFF		0x05000000UL
-#define FFB_SFB32_SIZE		0x01000000UL
-
-#define	FFB_SFB64_POFF		0x06000000UL
-#define FFB_SFB64_SIZE		0x02000000UL
-
-Bool
-FFBDRIScreenInit(ScreenPtr pScreen)
-{
-	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
-	FFBPtr pFfb = GET_FFB_FROM_SCRN(pScrn);
-	DRIInfoPtr pDRIInfo;
-	FFBDRIPtr pFfbDRI;
-
-	/* Check that the GLX, DRI, and DRM modules have been loaded by testing
-	 * for canonical symbols in each module.
-	 */
-	if (!xf86LoaderCheckSymbol("GlxSetVisualConfigs"))
-		return FALSE;
-	if (!xf86LoaderCheckSymbol("drmAvailable"))
-		return FALSE;
-        if (!xf86LoaderCheckSymbol("DRIQueryVersion")) {
-      		xf86DrvMsg(pScreen->myNum, X_ERROR,
-                 	"FFBDRIScreenInit failed (libdri.a too old)\n");
-		return FALSE;
-        }
-
-        /* Check the DRI version */
-        {
-      		int major, minor, patch;
-		DRIQueryVersion(&major, &minor, &patch);
-		if (major != DRIINFO_MAJOR_VERSION || minor < DRIINFO_MINOR_VERSION) {
-		xf86DrvMsg(pScreen->myNum, X_ERROR,
-                    "[dri] FFBDRIScreenInit failed because of a version mismatch.\n"
-		    "[dri] libdri version is %d.%d.%d but version %d.%d.x is needed.\n"
-		    "[dri]  Disabling DRI.\n",
-                    major, minor, patch,
-                    DRIINFO_MAJOR_VERSION, DRIINFO_MINOR_VERSION);
-		return FALSE;
-		}
-	}
-
-	pDRIInfo = DRICreateInfoRec();
-	if (pDRIInfo == NULL)
-		return FALSE;
-
-	pFfb->pDRIInfo = pDRIInfo;
-
-	pDRIInfo->drmDriverName = FFBKernelDriverName;
-	pDRIInfo->clientDriverName = FFBClientDriverName;
-
-	pDRIInfo->ddxDriverMajorVersion = 0;
-	pDRIInfo->ddxDriverMinorVersion = 1;
-	pDRIInfo->ddxDriverPatchVersion = 1;
-
-	pDRIInfo->busIdString = xalloc(64); /* Freed in DRIDestroyInfoRec */
-	sprintf(pDRIInfo->busIdString, "SBUS:%s", pFfb->psdp->device);
-
-	/* Dumb rendering port for now... */
-	pDRIInfo->frameBufferPhysicalAddress = FFB_DFB24_POFF;
-	pDRIInfo->frameBufferSize = FFB_DFB24_SIZE;
-	pDRIInfo->frameBufferStride = (2048 * 4);
-
-	/* XXX */
-	pDRIInfo->ddxDrawableTableEntry = 15;
-	pDRIInfo->maxDrawableTableEntry = 15;
-	pDRIInfo->SAREASize = (SAREA_MAX + (0x2000 - 1)) & ~(0x2000 - 1);
-
-	pFfbDRI = (FFBDRIPtr) xcalloc(sizeof(FFBDRIRec), 1);
-	if (pFfbDRI == NULL) {
-		DRIDestroyInfoRec(pFfb->pDRIInfo);
-		return FALSE;
-	}
-
-	pDRIInfo->devPrivate		= pFfbDRI;
-	pDRIInfo->devPrivateSize	= sizeof(*pFfbDRI);
-	pDRIInfo->contextSize		= 0; /* kernel does ctx swaps */
-
-	pDRIInfo->CreateContext		= FFBDRICreateContext;
-	pDRIInfo->DestroyContext	= FFBDRIDestroyContext;
-	pDRIInfo->InitBuffers		= FFBDRIInitBuffers;
-	pDRIInfo->MoveBuffers		= FFBDRIMoveBuffers;
-	pDRIInfo->SetDrawableIndex	= FFBDRISetDrawableIndex;
-
-	/* Our InitBuffers depends heavily on this setting. */
-	pDRIInfo->bufferRequests	= DRI_3D_WINDOWS_ONLY;
-
-	pDRIInfo->createDummyCtx	= TRUE;
-	pDRIInfo->createDummyCtxPriv	= FALSE;
-
-	if (!DRIScreenInit(pScreen, pDRIInfo, &(pFfb->drmSubFD))) {
-                xf86DrvMsg(pScreen->myNum, X_ERROR,
-                           "[dri] DRIScreenInit failed.  Disabling DRI.\n");
-		DRIDestroyInfoRec(pFfb->pDRIInfo);
-		xfree(pFfbDRI);
-		return FALSE;
-	}
-
-#if 000 /* XXX this should be cleaned up and used */
-        /* Check the ffb DRM version */
-        version = drmGetVersion(info->drmFD);
-        if (version) {
-           if (version->version_major != 1 ||
-               version->version_minor < 0) {
-              /* incompatible drm version */
-              xf86DrvMsg(pScreen->myNum, X_ERROR,
-                         "[dri] FFBDRIScreenInit failed because of a version mismatch.\n"
-                         "[dri] ffb.o kernel module version is %d.%d.%d but version 1.0.x is needed.\n"
-                         "[dri] Disabling the DRI.\n",
-                         version->version_major,
-                         version->version_minor,
-                         version->version_patchlevel);
-              drmFreeVersion(version);
-              R128DRICloseScreen(pScreen);
-	    return FALSE;
-           }
-           drmFreeVersion(version);
-        }
-#endif
-
-	pFfb->pFfbSarea = DRIGetSAREAPrivate(pScreen);
-	init_ffb_sarea(pFfb, pFfb->pFfbSarea);
-
-	/* Setup device specific direct rendering memory maps. */
-	if (drmAddMap(pFfb->drmSubFD,
-		      FFB_FBC_REGS_POFF, FFB_FBC_REGS_SIZE,
-		      DRM_REGISTERS, 0, &pFfbDRI->hFbcRegs) < 0) {
-		DRICloseScreen(pScreen);
-		return FALSE;
-	}
-	pFfbDRI->sFbcRegs = FFB_FBC_REGS_SIZE;
-
-	xf86DrvMsg(pScreen->myNum, X_INFO,
-		   "[drm] FBC Register handle = 0x%08x\n",
-		   pFfbDRI->hFbcRegs);
-
-	if (drmAddMap(pFfb->drmSubFD,
-		      FFB_DAC_POFF, FFB_DAC_SIZE,
-		      DRM_REGISTERS, 0, &pFfbDRI->hDacRegs) < 0) {
-		DRICloseScreen(pScreen);
-		return FALSE;
-	}
-	pFfbDRI->sDacRegs = FFB_DAC_SIZE;
-
-	xf86DrvMsg(pScreen->myNum, X_INFO,
-		   "[drm] DAC Register handle = 0x%08x\n",
-		   pFfbDRI->hDacRegs);
-
-	/* Now add maps for the "Smart" views of the framebuffer. */
-	if (drmAddMap(pFfb->drmSubFD,
-		      FFB_SFB8R_POFF, FFB_SFB8R_SIZE,
-		      DRM_REGISTERS, 0, &pFfbDRI->hSfb8r) < 0) {
-		DRICloseScreen(pScreen);
-		return FALSE;
-	}
-	pFfbDRI->sSfb8r = FFB_SFB8R_SIZE;
-
-	xf86DrvMsg(pScreen->myNum, X_INFO,
-		   "[drm] SFB8R handle = 0x%08x\n",
-		   pFfbDRI->hSfb8r);
-
-	if (drmAddMap(pFfb->drmSubFD,
-		      FFB_SFB32_POFF, FFB_SFB32_SIZE,
-		      DRM_REGISTERS, 0, &pFfbDRI->hSfb32) < 0) {
-		DRICloseScreen(pScreen);
-		return FALSE;
-	}
-	pFfbDRI->sSfb32 = FFB_SFB32_SIZE;
-
-	xf86DrvMsg(pScreen->myNum, X_INFO,
-		   "[drm] SFB32 handle = 0x%08x\n",
-		   pFfbDRI->hSfb32);
-
-	if (drmAddMap(pFfb->drmSubFD,
-		      FFB_SFB64_POFF, FFB_SFB64_SIZE,
-		      DRM_REGISTERS, 0, &pFfbDRI->hSfb64) < 0) {
-		DRICloseScreen(pScreen);
-		return FALSE;
-	}
-	pFfbDRI->sSfb64 = FFB_SFB64_SIZE;
-
-	xf86DrvMsg(pScreen->myNum, X_INFO,
-		   "[drm] SFB64 handle = 0x%08x\n",
-		   pFfbDRI->hSfb64);
-
-	/* Setup visual configurations. */
-	if (!FFBDRIInitVisualConfigs(pScreen)) {
-		DRICloseScreen(pScreen);
-		return FALSE;
-	}
-
-	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-		   "[drm] Visual configs initialized\n");
-
-	return TRUE;
-}
-
-void
-FFBDRICloseScreen(ScreenPtr pScreen)
-{
-	FFBPtr pFfb = GET_FFB_FROM_SCREEN(pScreen);
-
-	DRICloseScreen(pScreen);
-
-	if (pFfb->pDRIInfo) {
-		DRIInfoPtr pDRIInfo = pFfb->pDRIInfo;
-
-		if (pDRIInfo->devPrivate)
-			xfree(pDRIInfo->devPrivate);
-		DRIDestroyInfoRec(pDRIInfo);
-		pFfb->pDRIInfo = NULL;
-	}
-
-	if (pFfb->pVisualConfigs) {
-		xfree(pFfb->pVisualConfigs);
-		pFfb->pVisualConfigs = NULL;
-	}
-	if (pFfb->pVisualConfigsPriv) {
-		xfree(pFfb->pVisualConfigsPriv);
-		pFfb->pVisualConfigsPriv = NULL;
-	}
-}
-
-static Bool
-FFBDRICreateContext(ScreenPtr pScreen, VisualPtr visual, drm_context_t hwContext,
-		 void *pVisualConfigPriv, DRIContextType context)
-{
-	/* Nothing to do... */
-	return TRUE;
-}
-
-static void
-FFBDRIDestroyContext(ScreenPtr pScreen, drm_context_t hwContext, DRIContextType context)
-{
-	/* Nothing to do... */
-}
-
-Bool
-FFBDRIFinishScreenInit(ScreenPtr pScreen)
-{
-	FFBPtr pFfb = GET_FFB_FROM_SCREEN(pScreen);
-	DRIInfoPtr pDRIInfo = pFfb->pDRIInfo;
-	FFBDRIPtr pFfbDRI = (FFBDRIPtr) pDRIInfo->devPrivate;
-	int i;
-
-	/* This belongs in the kernel.  I'm sorry, the rest
-	 * of the current DRI switching mechanisms just suck.
-	 */
-	pDRIInfo->driverSwapMethod = DRI_KERNEL_SWAP;
-
-	/* Copy over the fast/page filling parameters now that
-	 * acceleration has been fully setup.
-	 */
-	pFfbDRI->disable_pagefill = pFfb->disable_pagefill;
-	pFfbDRI->fastfill_small_area = FFB_FFPARMS(pFfb).fastfill_small_area;
-	pFfbDRI->pagefill_small_area = FFB_FFPARMS(pFfb).pagefill_small_area;
-	pFfbDRI->fastfill_height = FFB_FFPARMS(pFfb).fastfill_height;
-	pFfbDRI->fastfill_width = FFB_FFPARMS(pFfb).fastfill_width;
-	pFfbDRI->pagefill_height = FFB_FFPARMS(pFfb).pagefill_height;
-	pFfbDRI->pagefill_width = FFB_FFPARMS(pFfb).pagefill_width;
-	for (i = 0; i < 0x800; i++)
-		pFfbDRI->Pf_AlignTab[i] = pFfb->Pf_AlignTab[i];
-
-	return DRIFinishScreenInit(pScreen);
-}
-
-static void
-FFBDRIInitBuffers(WindowPtr pWin, RegionPtr prgn, CARD32 index)
-{
-	ScreenPtr pScreen = pWin->drawable.pScreen;
-	FFBPtr pFfb = GET_FFB_FROM_SCREEN(pScreen);
-	CreatorPrivWinPtr pFfbPrivWin = CreatorGetWindowPrivate(pWin);
-	ffb_fbcPtr ffb = pFfb->regs;
-	unsigned int fbc;
-	BoxPtr pBox;
-	int nBox;
-
-	fbc = pFfbPrivWin->fbc_base;
-	fbc = (fbc & ~FFB_FBC_WB_MASK) | FFB_FBC_WB_AB;
-	fbc = (fbc & ~FFB_FBC_XE_MASK) | FFB_FBC_XE_ON;
-	fbc = (fbc & ~FFB_FBC_RGBE_MASK) | FFB_FBC_RGBE_OFF;
-
-	pBox = REGION_RECTS(prgn);
-	nBox = (int) REGION_NUM_RECTS(prgn);
-	FFB_WRITE_ROP(pFfb, ffb, (FFB_ROP_NEW | (FFB_ROP_NEW << 8)));
-	FFB_WRITE_PPC(pFfb, ffb,
-		      (FFB_PPC_APE_DISABLE | FFB_PPC_CS_CONST | FFB_PPC_XS_WID),
-		      (FFB_PPC_APE_MASK | FFB_PPC_CS_MASK | FFB_PPC_XS_MASK));
-	FFB_WRITE_PMASK(pFfb, ffb, ~0);
-	FFB_WRITE_DRAWOP(pFfb, ffb, FFB_DRAWOP_RECTANGLE);
-	FFB_WRITE_FBC(pFfb, ffb, fbc);
-	FFB_WRITE_WID(pFfb, ffb, FFB_WID_WIN(pWin));
-
-	while(nBox--) {
-		register int x, y, w, h;
-
-		x = pBox->x1;
-		y = pBox->y1;
-		w = (pBox->x2 - x);
-		h = (pBox->y2 - y);
-		FFBFifo(pFfb, 4);
-		FFB_WRITE64(&ffb->by, y, x);
-		FFB_WRITE64_2(&ffb->bh, h, w);
-		pBox++;
-	}
-	pFfb->rp_active = 1;
-	FFBSync(pFfb, ffb);
-}
-
-static void
-FFBDRIMoveBuffers(WindowPtr pParent, DDXPointRec ptOldOrg,
-		  RegionPtr prgnSrc, CARD32 index)
-{
-}
-
-static void
-FFBDRISetDrawableIndex(WindowPtr pWin, CARD32 index)
-{
-	ScreenPtr pScreen = pWin->drawable.pScreen;
-	FFBPtr pFfb = GET_FFB_FROM_SCREEN(pScreen);
-	CreatorPrivWinPtr pFfbPrivWin = CreatorGetWindowPrivate(pWin);
-	unsigned int wid;
-
-	if (FFBWidIsShared(pFfb, pFfbPrivWin->wid)) {
-		wid = FFBWidUnshare(pFfb, pFfbPrivWin->wid);
-		if (wid == (unsigned int) -1)
-			return;
-
-		ErrorF("FFB: Allocated WID %x for DRI window.\n", wid);
-		pFfbPrivWin->wid = wid;
-
-		/* Now update the SAREA. */
-		pFfb->pFfbSarea->wid_table[index] = wid;
-	}
-}
--- a/src/ffb_drishare.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/* $XFree86$ */
-
-#ifndef _FFB_DRISHARE_H
-#define _FFB_DRISHARE_H
-
-typedef struct ffb_dri_state {
-	int		flags;
-#define FFB_DRI_FFB2		0x00000001
-#define FFB_DRI_FFB2PLUS	0x00000002
-#define FFB_DRI_PAC1		0x00000004
-#define FFB_DRI_PAC2		0x00000008
-
-	/* Indexed by DRI drawable id. */
-#define FFB_DRI_NWIDS	64
-	unsigned int	wid_table[FFB_DRI_NWIDS];
-} ffb_dri_state_t;
-
-#define FFB_DRISHARE(SAREA)	\
-	((ffb_dri_state_t *) (((char *)(SAREA)) + sizeof(drm_sarea_t)))
-
-typedef struct {
-	drm_handle_t	hFbcRegs;
-	drmSize		sFbcRegs;
-
-	drm_handle_t	hDacRegs;
-	drmSize		sDacRegs;
-
-	drm_handle_t	hSfb8r;
-	drmSize		sSfb8r;
-
-	drm_handle_t	hSfb32;
-	drmSize		sSfb32;
-
-	drm_handle_t	hSfb64;
-	drmSize		sSfb64;
-
-	/* Fastfill/Pagefill parameters. */
-	unsigned char	disable_pagefill;
-	int		fastfill_small_area;
-	int		pagefill_small_area;
-	int		fastfill_height;
-	int		fastfill_width;
-	int		pagefill_height;
-	int		pagefill_width;
-	short		Pf_AlignTab[0x800];
-} FFBDRIRec, *FFBDRIPtr;
-
-#endif /* !(_FFB_DRISHARE_H) */
--- a/src/ffb_driver.c
+++ b/src/ffb_driver.c
@@ -432,22 +432,6 @@ FFBPreInit(ScrnInfoPtr pScrn, int flags)
 	return FALSE;
     }
 
-#if 0
-/*#ifdef XF86DRI*/
-/*
- * Loading this automatically isn't compatible
- * to the behavior of other drivers
- */
-    if (xf86LoadSubModule(pScrn, "drm") == NULL) {
-	FFBFreeRec(pScrn);
-	return FALSE;
-    }
-
-    if (xf86LoadSubModule(pScrn, "dri") == NULL) {
-	FFBFreeRec(pScrn);
-	return FALSE;
-    }
-#endif
 
     /*********************
     set up clock and mode stuff
@@ -740,21 +724,6 @@ FFBScreenInit(int scrnIndex, ScreenPtr p
     if (!miSetPixmapDepths())
         return FALSE;
 
-#if 0 /*def XF86DRI*/
-    if (pFfb->ffb_type != afb_m3 && pFfb->ffb_type != afb_m6 &&
-	pFfb->NoAccel == FALSE) {
-	    pFfb->dri_enabled = FFBDRIScreenInit(pScreen);
-	    if (pFfb->dri_enabled == TRUE)
-		    xf86Msg(X_INFO, "%s: DRM initialized\n",
-			    pFfb->psdp->device);
-	    else
-		    xf86Msg(X_INFO, "%s: DRM setup failed\n",
-			    pFfb->psdp->device);
-    } else {
-	    pFfb->dri_enabled = FALSE;
-    }
-#endif
-
     /*
      * Call the framebuffer layer's ScreenInit function, and fill in other
      * pScreen fields.
@@ -832,21 +801,6 @@ FFBScreenInit(int scrnIndex, ScreenPtr p
     if (!pFfb->NoAccel)
 	    FFB_InitDGA(pScreen);
 
-#if 0 /*def XF86DRI*/
-    if (pFfb->dri_enabled) {
-	    /* Now that mi, fb, drm and others have done their thing, 
-	     * complete the DRI setup.
-	     */
-	    pFfb->dri_enabled = FFBDRIFinishScreenInit(pScreen);
-	    if (pFfb->dri_enabled)
-		    xf86Msg(X_INFO, "%s: DRM finish setup complete\n",
-			    pFfb->psdp->device);
-	    else
-		    xf86Msg(X_INFO, "%s: DRM finish setup failed\n",
-			    pFfb->psdp->device);
-    }
-#endif
-
     xf86DPMSInit(pScreen, FFBDPMSSet, 0);
 
     pFfb->CloseScreen = pScreen->CloseScreen;
@@ -948,11 +902,6 @@ FFBCloseScreen(int scrnIndex, ScreenPtr 
 	ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
 	FFBPtr pFfb = GET_FFB_FROM_SCRN(pScrn);
 
-#if 0 /*def XF86DRI*/
-	if (pFfb->dri_enabled)
-		FFBDRICloseScreen(pScreen);
-#endif
-
 	/* Restore kernel ramdac state before we unmap registers. */
 	FFBDacFini(pFfb);
 
@@ -1010,7 +959,9 @@ FFBSaveScreen(ScreenPtr pScreen, int mod
        done in "ffb_dac.c" `for aesthetic reasons.'
     */
 {
-    return FFBDacSaveScreen(GET_FFB_FROM_SCREEN(pScreen), mode);
+    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
+
+    return FFBDacSaveScreen(GET_FFB_FROM_SCRN(pScrn), mode);
 }
 
 static void
--- a/src/ffb_rcache.h
+++ b/src/ffb_rcache.h
@@ -147,57 +147,8 @@ extern void __FFB_Attr_Raw(FFBPtr pFfb,
 
 #define FFB_PPC_GCMASK	(FFB_PPC_APE_MASK | FFB_PPC_CS_MASK)
 
-/* This is for loading the FFB attributes for the case where
- * where most of the values come directly from the graphics
- * context and only the PPC and DRAWOP are variable.
- */
-extern void __FFB_Attr_GC(FFBPtr pFfb, GCPtr pGC, WindowPtr pWin,
-			  unsigned int ppc, int drawop);
-
-#define FFB_ATTR_GC(__fpriv, __pgc, __pwin, __ppc, __drawop)		\
-do {	CreatorPrivWinPtr __winpriv = CreatorGetWindowPrivate(__pwin);	\
-	unsigned int __rop = ((__pgc)->alu | FFB_ROP_EDIT_BIT);		\
-	unsigned int __fbc = ((__winpriv)->fbc_base);			\
-	__fbc &= ~FFB_FBC_XE_MASK;					\
-	__fbc |= FFB_FBC_XE_OFF;					\
-	__rop |= (FFB_ROP_NEW << 8);					\
-	if ((((__fpriv)->ppc_cache & FFB_PPC_GCMASK) != (__ppc))||	\
-	    ((__fpriv)->pmask_cache != ((__pgc)->planemask))	||	\
-	    ((__fpriv)->rop_cache != (__rop))			||	\
-	    ((__fpriv)->drawop_cache != (__drawop))		||	\
-	    ((__fpriv)->fg_cache != ((__pgc)->fgPixel))		||	\
-	    ((__fpriv)->fbc_cache != __fbc))				\
-		__FFB_Attr_GC(__fpriv, __pgc, __pwin, __ppc, __drawop);	\
-} while(0)
-
 #define FFB_PPC_WINMASK	(FFB_PPC_APE_MASK | FFB_PPC_CS_MASK | FFB_PPC_XS_MASK)
 
-extern void __FFB_Attr_FastfillWin(FFBPtr pFfb, WindowPtr pWin,
-				   unsigned int ppc, unsigned int pixel);
-
-#define FFB_ATTR_FFWIN(__fpriv, __pwin, __ppc, __pixel) \
-do {	CreatorPrivWinPtr __winpriv = CreatorGetWindowPrivate(__pwin);	\
-	unsigned int ___ppc = (__ppc) | FFB_PPC_XS_WID;			\
-	unsigned int __fbc = (__winpriv)->fbc_base; \
-	unsigned int __rop = (FFB_ROP_NEW|(FFB_ROP_NEW<<8)); \
-	if((__fpriv)->has_double_buffer) { \
-		__fbc &= ~FFB_FBC_WB_MASK; \
-		__fbc |= FFB_FBC_WB_AB; \
-	} \
-	__fbc &= ~(FFB_FBC_XE_MASK | FFB_FBC_RGBE_MASK); \
-	__fbc |= FFB_FBC_XE_ON | FFB_FBC_RGBE_ON; \
-	if (pFfb->ffb_res == ffb_res_high) \
-		__fbc |= FFB_FBC_WB_B; \
-	if ((((__fpriv)->ppc_cache & FFB_PPC_WINMASK) != (___ppc))||	\
-	    ((__fpriv)->pmask_cache != 0x00ffffff)		||	\
-	    ((__fpriv)->rop_cache!= __rop)			||	\
-	    ((__fpriv)->drawop_cache != FFB_DRAWOP_FASTFILL)	||	\
-	    ((__fpriv)->fg_cache != (__pixel))			||	\
-	    ((__fpriv)->fbc_cache != __fbc)			||	\
-	    ((__fpriv)->wid_cache != ((__winpriv)->wid)))		\
-		__FFB_Attr_FastfillWin(__fpriv, __pwin, ___ppc, __pixel);\
-} while (0)
-
 /* We have to be careful when copying windows around.  For that
  * case we will use either VIS copies or hw accelerated VSCROLL.
  * All of the planes needs to be copied in the framebuffer from
@@ -327,7 +278,4 @@ do {	unsigned int __rop = (FFB_ROP_OLD |
 	} \
 } while(0)
 
-#define FFB_FBC_WIN(pWin)	CreatorGetWindowPrivate(pWin)->fbc_base
-#define FFB_WID_WIN(pWin)	CreatorGetWindowPrivate(pWin)->wid
-
 #endif /* FFBRCACHE_H */
--- a/src/ffb_wid.c
+++ b/src/ffb_wid.c
@@ -449,20 +449,3 @@ FFBWidChangeBuffer(FFBPtr pFfb, unsigned
 		update_wids(pFfb, index);
 	}
 }
-
-/* Used by DRI part of driver. */
-Bool
-FFBWidIsShared(FFBPtr pFfb, unsigned int wid)
-{
-	ffb_dac_info_t *p = &pFfb->dac_info;
-	ffb_wid_pool_t *table = &p->wid_table;
-	int index = wid >> table->wid_shift;
-
-	if (index < 0 || index >= table->num_wids)
-		return TRUE;
-
-	if (table->wid_pool[index].canshare == TRUE)
-		return TRUE;
-
-	return FALSE;
-}
